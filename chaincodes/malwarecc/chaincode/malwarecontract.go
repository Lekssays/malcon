package chaincode

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"time"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
	. "github.com/iotaledger/iota.go/api"
	"github.com/iotaledger/iota.go/bundle"
	"github.com/iotaledger/iota.go/converter"
	"github.com/iotaledger/iota.go/trinary"
	"github.com/op/go-logging"
)

var log = logging.MustGetLogger("example")

// Example format string. Everything except the message has a custom color
// which is dependent on the log level. Many fields have a custom output
// formatting too, eg. the time returns the hour down to the milli second.
var format = logging.MustStringFormatter(
	`%{color}%{time:15:04:05.000} %{shortfunc} â–¶ %{level:.4s} %{id:03x}%{color:reset} %{message}`,
)

// SmartContract defines the structure of a smart contract
type SmartContract struct {
	contractapi.Contract
}

// Malware defines the structure of a malware entry
type Malware struct {
	ID            string   `json:"ID"`
	Filename      string   `json:"filename"`
	Family        string   `json:"family"`
	Checksum      string   `json:"checksum"`
	DetectionTime string   `json:"detection_time"`
	NearbyPeers   []string `json:"nearbypeers"`
}

// Election defines the structure of a election entry
type Election struct {
	ID        string `json:"ID"`
	ActionID  string `json:"action_id"`
	Timestamp string `json:"timestamp"`
}

// Action defines the structure of action entry
type Action struct {
	ID         string `json:"ID"`
	StrategyID string `json:"strategy_id"`
	MalwareID  string `json:"malware_id"`
	Timestamp  string `json:"timestamp"`
}

// InitLedger adds a base set of malware entries to the ledger
func (s *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {
	malwares := []Malware{
		{
			ID:            "peer0/1",
			Filename:      "download.sh",
			Family:        "Mirai",
			Checksum:      "0c1675bf83c5031b3df8db0cba04400af169d9a6",
			DetectionTime: "300",
			NearbyPeers:   []string{"192.168.5.11", "192.168.55.11"},
		},
		{
			ID:            "peer0/2",
			Filename:      "ads.sh",
			Family:        "Torii",
			Checksum:      "d3ae921b9687f1a4a0cb04e1bd4b064a407e723b",
			DetectionTime: "400",
			NearbyPeers:   []string{"192.168.5.22", "192.168.55.22"},
		},
		{
			ID:            "peer0/3",
			Filename:      "update.sh",
			Family:        "Muhstik",
			Checksum:      "36eae9b881af69cb92e1129608866825085742be",
			DetectionTime: "500",
			NearbyPeers:   []string{"192.168.5.33", "192.168.55.33"},
		},
	}

	for _, malware := range malwares {
		malwareJSON, err := json.Marshal(malware)
		if err != nil {
			return err
		}

		err = ctx.GetStub().PutState(malware.ID, malwareJSON)
		if err != nil {
			return fmt.Errorf("failed to put to world state. %v", err)
		}
	}

	return nil
}

// CreateElection initiates an election
func CreateElection(electionID string, actionID string, timestamp string) (string, bool) {
	backend := logging.NewLogBackend(os.Stderr, "", 0)
	backendFormatter := logging.NewBackendFormatter(backend, format)
	logging.SetBackend(backend, backendFormatter)

	const node = "https://nodes.devnet.iota.org"
	api, err := ComposeAPI(HTTPClientSettings{URI: node})

	if err != nil {
		log.Error(err)
		return "", false
	}

	const depth = 3
	const minimumWeightMagnitude = 9
	const tag = "MALCONELEC"
	// Just a dummy address and a seed that is not used since the transaction is has zero value (expected by iota)
	const address = trinary.Trytes("ZLGVEQ9JUZZWCZXLWVNTHBDX9G9KZTJP9VEERIIFHY9SIQKYBVAHIMLHXPQVE9IXFDDXNHQINXJDRPFDXNYVAPLZAW")
	const seed = trinary.Trytes("JBN9ZRCOH9YRUGSWIQNZWAIFEZUBDUGTFPVRKXWPAUCEQQFS9NHPQLXCKZKRHVCCUZNF9CZZWKXRZVCWQ")
	var data = fmt.Sprintf("{'election_id' : '%s', 'action_id': '%s', 'timestamp': '%s'}", electionID, actionID, timestamp)
	message, err := converter.ASCIIToTrytes(data)

	if err != nil {
		log.Error(err)
		return "", false
	}

	transfers := bundle.Transfers{
		{
			Address: address,
			Value:   0,
			Message: message,
			Tag:     tag,
		},
	}

	trytes, err := api.PrepareTransfers(seed, transfers, PrepareTransfersOptions{})

	if err != nil {
		log.Error(err)
		return "", false
	}

	myBundle, err := api.SendTrytes(trytes, depth, minimumWeightMagnitude)
	if err != nil {
		log.Error(err)
		return "", false
	}

	log.Infof("Transaction hash: %s", bundle.TailTransactionHash(myBundle))
	return bundle.TailTransactionHash(myBundle), true
}

// RandInt is a helper function that generate random integers
func RandInt(min int, max int) int {
	return min + rand.Intn(max-min)
}

// RandomNumber is a helper function that generates a random string
func RandomNumber(l int) string {
	bytes := make([]byte, l)
	for i := 0; i < l; i++ {
		bytes[i] = byte(RandInt(48, 57))
	}
	return string(bytes)
}

// CreateAction issues a new action taken after evaluating the available strategies
func (s *SmartContract) CreateAction(ctx contractapi.TransactionContextInterface, malwareID string) (string, error) {
	// TODO: add logic to choose a strategy
	strategyID := "OLGSLZJTSPRXLNNCKERMB"
	timestamp := fmt.Sprintf("%d", time.Now().Unix())

	rand.Seed(time.Now().UTC().UnixNano())
	ra := RandomNumber(10)
	id := fmt.Sprintf("AC_%s", ra)

	rand.Seed(time.Now().UTC().UnixNano())
	re := RandomNumber(10)
	electionID := fmt.Sprintf("ELEC_%s", re)

	action := Action{
		ID:         id,
		StrategyID: strategyID,
		MalwareID:  malwareID,
		Timestamp:  timestamp,
	}

	log.Debug(action)

	actionJSON, err := json.Marshal(action)
	log.Debug(actionJSON)
	if err != nil {
		return "", err
	}

	txid, isSubmitted := CreateElection(electionID, id, timestamp)
	if isSubmitted == false {
		return "", fmt.Errorf("CreateElection failed")
	}

	return txid, ctx.GetStub().PutState(id, actionJSON)
}

// CreateMalware issues a new malware entry to the world state with given details.
func (s *SmartContract) CreateMalware(ctx contractapi.TransactionContextInterface, id string, filename string, family string, checksum string, detectionTime string, nearbypeers []string) error {
	exists, err := s.MalwareExists(ctx, id)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("the malware %s already exists", id)
	}

	malware := Malware{
		ID:            id,
		Filename:      filename,
		Family:        family,
		Checksum:      checksum,
		DetectionTime: detectionTime,
		NearbyPeers:   nearbypeers,
	}
	malwareJSON, err := json.Marshal(malware)

	if err != nil {
		return err
	}

	return ctx.GetStub().PutState(id, malwareJSON)
}

// ReadAction returns the action entry stored in the world state with given id.
func (s *SmartContract) ReadAction(ctx contractapi.TransactionContextInterface, id string) (*Action, error) {
	actionJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %v", err)
	}
	if actionJSON == nil {
		return nil, fmt.Errorf("the action %s does not exist", id)
	}

	var action Action
	err = json.Unmarshal(actionJSON, &action)
	if err != nil {
		return nil, err
	}

	return &action, nil
}

// ReadMalware returns the malware entry stored in the world state with given id.
func (s *SmartContract) ReadMalware(ctx contractapi.TransactionContextInterface, id string) (*Malware, error) {
	malwareJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %v", err)
	}
	if malwareJSON == nil {
		return nil, fmt.Errorf("the malware %s does not exist", id)
	}

	var malware Malware
	err = json.Unmarshal(malwareJSON, &malware)
	if err != nil {
		return nil, err
	}

	return &malware, nil
}

// MalwareExists returns true when a malware entry with given ID exists in world state
func (s *SmartContract) MalwareExists(ctx contractapi.TransactionContextInterface, id string) (bool, error) {
	malwareJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return false, fmt.Errorf("failed to read from world state: %v", err)
	}

	return malwareJSON != nil, nil
}

// GetAllMalware returns all malware found in world state
func (s *SmartContract) GetAllMalware(ctx contractapi.TransactionContextInterface) ([]*Malware, error) {
	// range query with empty string for startKey and endKey does an
	// open-ended query of all malware in the chaincode namespace.
	resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	var malwares []*Malware
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return nil, err
		}

		var malware Malware
		err = json.Unmarshal(queryResponse.Value, &malware)
		if err != nil {
			return nil, err
		}
		malwares = append(malwares, &malware)
	}

	return malwares, nil
}

// GetAllActions returns all actions found in world state
func (s *SmartContract) GetAllActions(ctx contractapi.TransactionContextInterface) ([]*Action, error) {
	resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	var actions []*Action
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return nil, err
		}

		var action Action
		err = json.Unmarshal(queryResponse.Value, &action)
		if err != nil {
			return nil, err
		}
		actions = append(actions, &action)
	}

	return actions, nil
}
