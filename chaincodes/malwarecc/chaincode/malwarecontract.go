package chaincode

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
	"github.com/hyperledger/fabric/common/util"
	. "github.com/iotaledger/iota.go/api"
	"github.com/iotaledger/iota.go/bundle"
	"github.com/iotaledger/iota.go/converter"
	"github.com/iotaledger/iota.go/trinary"
	"github.com/op/go-logging"
)

var log = logging.MustGetLogger("example")

// Example format string. Everything except the message has a custom color
// which is dependent on the log level. Many fields have a custom output
// formatting too, eg. the time returns the hour down to the milli second.
var format = logging.MustStringFormatter(
	`%{color}%{time:15:04:05.000} %{shortfunc} â–¶ %{level:.4s} %{id:03x}%{color:reset} %{message}`,
)

// SmartContract defines the structure of a smart contract
type SmartContract struct {
	contractapi.Contract
}

// Election defines the structure of a election entry
type Election struct {
	ID         string   `json:"ID"`
	ActionID   string   `json:"action_id"`
	Timestamp  string   `json:"timestamp"`
	Target     string   `json:"target"`
	Strategies []string `json:"strategies"`
}

// Malware defines the structure of a malware entry
type Malware struct {
	ID            string   `json:"ID"`
	Filename      string   `json:"filename"`
	Path          string   `json:"path"`
	Family        string   `json:"family"`
	Checksum      string   `json:"checksum"`
	DetectionTime string   `json:"detection_time"`
	Detector      string   `json:"detector"`
	Propagates    bool     `json:"propagates"`
	Actions       []string `json:"actions"`
	Ports         []int    `json:"ports"`
}

// Process defines the structure of the most critical process a peer runs
type Process struct {
	PID        string `json:"ID"`
	Replicated bool   `json:"replicated"`
	Formatting bool   `json:"formatting"`
	Rebooting  bool   `json:"rebooting"`
}

// Peer defines the structure of a peer entry
type Peer struct {
	ID         string   `json:"ID"`
	Neighbors  []string `json:"neighbors"`
	LastUpdate string   `json:"last_update"`
	Process    Process  `json:"critical_process"`
}

// InitLedger adds a base set of malware entries to the ledger
func (s *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {
	malwares := []Malware{
		{
			ID:            "peer0/1",
			Filename:      "download.sh",
			Path:          "/user/home/Desktop/download.sh",
			Family:        "Mirai",
			Checksum:      "0c1675bf83c5031b3df8db0cba04400af169d9a6",
			DetectionTime: "300",
			Detector:      "peer0.org1.example.com",
			Propagates:    true,
			Actions:       []string{"DF"},
			Ports:         []int{1337},
		},
		{
			ID:            "peer0/2",
			Filename:      "ads.sh",
			Path:          "/user/home/Download/ads.sh",
			Family:        "Torii",
			Checksum:      "d3ae921b9687f1a4a0cb04e1bd4b064a407e723b",
			DetectionTime: "400",
			Detector:      "peer0.org2.example.com",
			Propagates:    false,
			Actions:       []string{"EF", "CR", "M"},
			Ports:         []int{4444, 6565},
		},
		{
			ID:            "peer0/3",
			Filename:      "update.sh",
			Path:          "/user/home/Desktop/update.sh",
			Family:        "Muhstik",
			Checksum:      "36eae9b881af69cb92e1129608866825085742be",
			DetectionTime: "500",
			Detector:      "peer0.org3.example.com",
			Propagates:    false,
			Actions:       []string{"DF", "OP"},
			Ports:         []int{},
		},
	}

	for _, malware := range malwares {
		malwareJSON, err := json.Marshal(malware)
		if err != nil {
			return err
		}

		err = ctx.GetStub().PutState(malware.ID, malwareJSON)
		if err != nil {
			return fmt.Errorf("failed to put to world state. %v", err)
		}
	}

	return nil
}

// CreateElection initiates an election
func CreateElection(electionID string, timestamp string, target string, strategies []string, ports []int, path string) (string, bool) {
	backend := logging.NewLogBackend(os.Stderr, "", 0)
	backendFormatter := logging.NewBackendFormatter(backend, format)
	logging.SetBackend(backend, backendFormatter)

	const node = "https://nodes.devnet.iota.org"
	api, err := ComposeAPI(HTTPClientSettings{URI: node})

	if err != nil {
		log.Error(err)
		return "", false
	}

	const depth = 3
	const minimumWeightMagnitude = 9
	const tag = "MALCONELECVT"
	// Just a dummy address and a seed that is not used since the transaction has zero value (expected by iota)
	const address = trinary.Trytes("ZLGVEQ9JUZZWCZXLWVNTHBDX9G9KZTJP9VEERIIFHY9SIQKYBVAHIMLHXPQVE9IXFDDXNHQINXJDRPFDXNYVAPLZAW")
	const seed = trinary.Trytes("JBN9ZRCOH9YRUGSWIQNZWAIFEZUBDUGTFPVRKXWPAUCEQQFS9NHPQLXCKZKRHVCCUZNF9CZZWKXRZVCWQ")

	for i := range strategies {
		strategies[i] = "\"" + strategies[i] + "\""
	}
	printableStrategies := strings.Join(strategies, ",")

	tmpPorts := make([]string, len(ports))
	for i := range ports {
		tmpPorts[i] = strconv.Itoa(ports[i])
	}
	printablePorts := strings.Join(tmpPorts, ",")

	var data = fmt.Sprintf("{\"election_id\" : \"%s\", \"timestamp\": \"%s\", \"target\": \"%s\", \"strategies\": [%+v], \"ports\": [%+v], \"path\": \"%s\"}", electionID, timestamp, target, printableStrategies, printablePorts, path)
	message, err := converter.ASCIIToTrytes(data)

	if err != nil {
		log.Error(err)
		return "", false
	}

	transfers := bundle.Transfers{
		{
			Address: address,
			Value:   0,
			Message: message,
			Tag:     tag,
		},
	}

	trytes, err := api.PrepareTransfers(seed, transfers, PrepareTransfersOptions{})

	if err != nil {
		log.Error(err)
		return "", false
	}

	myBundle, err := api.SendTrytes(trytes, depth, minimumWeightMagnitude)
	if err != nil {
		log.Error(err)
		return "", false
	}

	log.Infof("Transaction hash: %s", bundle.TailTransactionHash(myBundle))
	return bundle.TailTransactionHash(myBundle), true
}

// BroadcastEmergency initiates an election
func BroadcastEmergency(emergencyID string, timestamp string, ports []int, initiator string) (string, bool) {
	backend := logging.NewLogBackend(os.Stderr, "", 0)
	backendFormatter := logging.NewBackendFormatter(backend, format)
	logging.SetBackend(backend, backendFormatter)

	const node = "https://nodes.devnet.iota.org"
	api, err := ComposeAPI(HTTPClientSettings{URI: node})

	if err != nil {
		log.Error(err)
		return "", false
	}

	const depth = 3
	const minimumWeightMagnitude = 9
	const tag = "MALCONEMERGVT"
	// Just a dummy address and a seed that is not used since the transaction has zero value (expected by iota)
	const address = trinary.Trytes("ZLGVEQ9JUZZWCZXLWVNTHBDX9G9KZTJP9VEERIIFHY9SIQKYBVAHIMLHXPQVE9IXFDDXNHQINXJDRPFDXNYVAPLZAW")
	const seed = trinary.Trytes("JBN9ZRCOH9YRUGSWIQNZWAIFEZUBDUGTFPVRKXWPAUCEQQFS9NHPQLXCKZKRHVCCUZNF9CZZWKXRZVCWQ")

	tmpPorts := make([]string, len(ports))
	for i := range ports {
		tmpPorts[i] = strconv.Itoa(ports[i])
	}
	printablePorts := strings.Join(tmpPorts, ",")

	var data = fmt.Sprintf("{\"emergency_id\" : \"%s\", \"timestamp\": \"%s\", \"ports\": [%+v], \"initiator\": \"%s\"}", emergencyID, timestamp, printablePorts, initiator)
	message, err := converter.ASCIIToTrytes(data)

	if err != nil {
		log.Error(err)
		return "", false
	}

	transfers := bundle.Transfers{
		{
			Address: address,
			Value:   0,
			Message: message,
			Tag:     tag,
		},
	}

	trytes, err := api.PrepareTransfers(seed, transfers, PrepareTransfersOptions{})

	if err != nil {
		log.Error(err)
		return "", false
	}

	myBundle, err := api.SendTrytes(trytes, depth, minimumWeightMagnitude)
	if err != nil {
		log.Error(err)
		return "", false
	}

	log.Infof("Transaction hash: %s", bundle.TailTransactionHash(myBundle))
	return bundle.TailTransactionHash(myBundle), true
}

// RandInt is a helper function that generate random integers
func RandInt(min int, max int) int {
	return min + rand.Intn(max-min)
}

// RandomNumber is a helper function that generates a random string
func RandomNumber(l int) string {
	bytes := make([]byte, l)
	for i := 0; i < l; i++ {
		bytes[i] = byte(RandInt(48, 57))
	}
	return string(bytes)
}

// UnionStrategies unions two sets of strategies
func UnionStrategies(a map[string]bool, b map[string]bool) map[string]bool {
	healingStrategies := map[string]bool{}
	for k := range a {
		healingStrategies[k] = true
	}
	for k := range b {
		healingStrategies[k] = true
	}
	return healingStrategies
}

// IntersectStrategies intersects two sets of strategies
func IntersectStrategies(a map[string]bool, b map[string]bool) map[string]bool {
	strategies := map[string]bool{}
	for k := range a {
		if b[k] {
			strategies[k] = true
		}
	}
	return strategies
}

// GetStrategies contains the process and malware matrices
func GetStrategies(actions []string, propagates bool, replicated bool, formatting bool, rebooting bool) []string {
	actionsMappings := map[string]int{
		"EF": 0,
		"DF": 1,
		"CR": 2,
		"M":  3,
		"SR": 4,
		"OP": 5,
	}

	existsMappings := map[bool]int{
		true:  0,
		false: 1,
	}

	malwareMatrix := [2][6][]string{
		{[]string{"F"}, []string{"DF", "CP"}, []string{"DF", "R", "CP"}, []string{"DF", "CP"}, []string{"DF", "CP", "R"}, []string{"DF", "CP"}},
		{[]string{"F"}, []string{"DF"}, []string{"DF", "R"}, []string{"DF", "CP"}, []string{"DF", "CP", "R"}, []string{"DF", "CP"}},
	}

	processMatrix := [3][]string{
		[]string{"F", "R", "DF", "CP"}, []string{"R", "DF", "CP"}, []string{"DF", "CP"},
	}

	malwareStrategies := map[string]bool{}
	for _, action := range actions {
		tmpStrategies := malwareMatrix[existsMappings[propagates]][actionsMappings[action]]
		for _, strategy := range tmpStrategies {
			malwareStrategies[strategy] = true
		}
	}

	processStrategies := map[string]bool{}
	if replicated || formatting {
		for _, strategy := range processMatrix[0] {
			processStrategies[strategy] = true
		}
	}

	if (!replicated || !formatting) && rebooting {
		for _, strategy := range processMatrix[1] {
			processStrategies[strategy] = true
		}
	}

	if !replicated && !formatting && !rebooting {
		for _, strategy := range processMatrix[2] {
			processStrategies[strategy] = true
		}
	}

	healingStrategies := UnionStrategies(malwareStrategies, processStrategies)
	finalStrategies := []string{}
	if propagates {
		emergencyStrategies := map[string]bool{"CP": true, "BC": true}
		finalStrategiesMap := IntersectStrategies(healingStrategies, emergencyStrategies)
		for k := range finalStrategiesMap {
			finalStrategies = append(finalStrategies, k)
		}
	} else {
		for k := range healingStrategies {
			finalStrategies = append(finalStrategies, k)
		}
	}
	return finalStrategies
}

// CreateAction issues a new action taken after evaluating the available strategies
func CreateAction(ctx contractapi.TransactionContextInterface, path string, detector string, actions []string, propagates bool, ports []int) (string, bool) {
	chainCodeArgs := util.ToChaincodeArgs("ReadPeer", detector)
	response := ctx.GetStub().InvokeChaincode("peer", chainCodeArgs, "mychannel")
	log.Infof("Query chaincode: %s", string(response.Payload))

	peerJSON := response.Payload
	var peer Peer
	err := json.Unmarshal(peerJSON, &peer)

	if err != nil {
		return "", false
	}

	replicated := peer.Process.Replicated
	formatting := peer.Process.Formatting
	rebooting := peer.Process.Rebooting

	strategies := GetStrategies(actions, propagates, replicated, formatting, rebooting)
	log.Info(strategies)

	if propagates {
		// broadcast in IOTA
		timestamp := fmt.Sprintf("%d", time.Now().Unix())
		rand.Seed(time.Now().UTC().UnixNano())
		rem := RandomNumber(10)
		emergencyID := fmt.Sprintf("EMERG_%s", rem)
		txid, status := BroadcastEmergency(emergencyID, timestamp, ports, detector)
		if status {
			log.Infof(txid)
		}

		// for all neighbors close ports
		emergencyStrategies := []string{"CP"}
		for i := range peer.Neighbors {
			timestamp := fmt.Sprintf("%d", time.Now().Unix())

			rand.Seed(time.Now().UTC().UnixNano())
			re := RandomNumber(10)
			electionID := fmt.Sprintf("ELEC_%s", re)

			txid, isSubmitted := CreateElection(electionID, timestamp, peer.Neighbors[i], emergencyStrategies, ports, path)
			if isSubmitted {
				log.Infof(txid)
			}
		}
	}

	timestamp := fmt.Sprintf("%d", time.Now().Unix())

	rand.Seed(time.Now().UTC().UnixNano())
	re := RandomNumber(10)
	electionID := fmt.Sprintf("ELEC_%s", re)

	txid, isSubmitted := CreateElection(electionID, timestamp, detector, strategies, ports, path)
	if isSubmitted == false {
		return "CreateElection failed", false
	}

	return txid, true

}

// CreateMalware issues a new malware entry to the world state with given details.
func (s *SmartContract) CreateMalware(ctx contractapi.TransactionContextInterface, id string, filename string, path string, family string, checksum string, detectionTime string, detector string, propagates bool, actions []string, ports []int) (string, error) {
	exists, err := s.MalwareExists(ctx, id)
	if err != nil {
		return "", err
	}

	if exists {
		return "", fmt.Errorf("the malware %s already exists", id)
	}

	malware := Malware{
		ID:            id,
		Filename:      filename,
		Path:          path,
		Family:        family,
		Checksum:      checksum,
		DetectionTime: detectionTime,
		Detector:      detector,
		Propagates:    propagates,
		Actions:       actions,
		Ports:         ports,
	}
	malwareJSON, err := json.Marshal(malware)

	if err != nil {
		return "", err
	}

	// Invoke Action Chaincode
	txid, status := CreateAction(ctx, path, detector, actions, propagates, ports)
	if status {
		return txid, ctx.GetStub().PutState(id, malwareJSON)
	}
	return "", fmt.Errorf("failure to submit to IOTA")
}

// ReadMalware returns the malware entry stored in the world state with given id.
func (s *SmartContract) ReadMalware(ctx contractapi.TransactionContextInterface, id string) (*Malware, error) {
	malwareJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %v", err)
	}
	if malwareJSON == nil {
		return nil, fmt.Errorf("the malware %s does not exist", id)
	}

	var malware Malware
	err = json.Unmarshal(malwareJSON, &malware)
	if err != nil {
		return nil, err
	}

	return &malware, nil
}

// MalwareExists returns true when a malware entry with given ID exists in world state
func (s *SmartContract) MalwareExists(ctx contractapi.TransactionContextInterface, id string) (bool, error) {
	malwareJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return false, fmt.Errorf("failed to read from world state: %v", err)
	}

	return malwareJSON != nil, nil
}

// GetAllMalware returns all malware found in world state
func (s *SmartContract) GetAllMalware(ctx contractapi.TransactionContextInterface) ([]*Malware, error) {
	// range query with empty string for startKey and endKey does an
	// open-ended query of all malware in the chaincode namespace.
	resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	var malwares []*Malware
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return nil, err
		}

		var malware Malware
		err = json.Unmarshal(queryResponse.Value, &malware)
		if err != nil {
			return nil, err
		}
		malwares = append(malwares, &malware)
	}

	return malwares, nil
}
