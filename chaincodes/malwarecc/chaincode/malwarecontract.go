package chaincode

import (
	"encoding/json"
	"fmt"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
	"github.com/hyperledger/fabric/common/util"
	"github.com/op/go-logging"
)

var log = logging.MustGetLogger("example")

// Example format string. Everything except the message has a custom color
// which is dependent on the log level. Many fields have a custom output
// formatting too, eg. the time returns the hour down to the milli second.
var format = logging.MustStringFormatter(
	`%{color}%{time:15:04:05.000} %{shortfunc} â–¶ %{level:.4s} %{id:03x}%{color:reset} %{message}`,
)

// SmartContract defines the structure of a smart contract
type SmartContract struct {
	contractapi.Contract
}

// Malware defines the structure of a malware entry
type Malware struct {
	ID            string   `json:"ID"`
	Filename      string   `json:"filename"`
	Path          string   `json:"path"`
	Family        string   `json:"family"`
	Checksum      string   `json:"checksum"`
	DetectionTime string   `json:"detection_time"`
	Detector      string   `json:"detector"`
	Propagates    bool     `json:"propagates"`
	Actions       []string `json:"actions"`
	Ports         []int    `json:"ports"`
}

// InitLedger adds a base set of malware entries to the ledger
func (s *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {
	malwares := []Malware{
		{
			ID:            "peer0/1",
			Filename:      "download.sh",
			Path:          "/user/home/Desktop/download.sh",
			Family:        "Mirai",
			Checksum:      "0c1675bf83c5031b3df8db0cba04400af169d9a6",
			DetectionTime: "300",
			Detector:      "peer0.org1.example.com",
			Propagates:    true,
			Actions:       []string{"DF"},
			Ports:         []int{1337},
		},
		{
			ID:            "peer0/2",
			Filename:      "ads.sh",
			Path:          "/user/home/Download/ads.sh",
			Family:        "Torii",
			Checksum:      "d3ae921b9687f1a4a0cb04e1bd4b064a407e723b",
			DetectionTime: "400",
			Detector:      "peer0.org2.example.com",
			Propagates:    false,
			Actions:       []string{"EF", "CR", "M"},
			Ports:         []int{4444, 6565},
		},
		{
			ID:            "peer0/3",
			Filename:      "update.sh",
			Path:          "/user/home/Desktop/update.sh",
			Family:        "Muhstik",
			Checksum:      "36eae9b881af69cb92e1129608866825085742be",
			DetectionTime: "500",
			Detector:      "peer0.org3.example.com",
			Propagates:    false,
			Actions:       []string{"DF", "OP"},
			Ports:         []int{},
		},
	}

	for _, malware := range malwares {
		malwareJSON, err := json.Marshal(malware)
		if err != nil {
			return err
		}

		err = ctx.GetStub().PutState(malware.ID, malwareJSON)
		if err != nil {
			return fmt.Errorf("failed to put to world state. %v", err)
		}
	}

	return nil
}

// CreateMalware issues a new malware entry to the world state with given details.
func (s *SmartContract) CreateMalware(ctx contractapi.TransactionContextInterface, id string, filename string, path string, family string, checksum string, detectionTime string, detector string, propagates bool, actions []string, ports []int) error {
	exists, err := s.MalwareExists(ctx, id)
	if err != nil {
		return err
	}

	if exists {
		return fmt.Errorf("the malware %s already exists", id)
	}

	malware := Malware{
		ID:            id,
		Filename:      filename,
		Path:          path,
		Family:        family,
		Checksum:      checksum,
		DetectionTime: detectionTime,
		Detector:      detector,
		Propagates:    propagates,
		Actions:       actions,
		Ports:         ports,
	}
	malwareJSON, err := json.Marshal(malware)

	if err != nil {
		return err
	}

	// Invoke Action Chaincode
	chainCodeArgs := util.ToChaincodeArgs("CreateAction", id)
	response := ctx.GetStub().InvokeChaincode("action", chainCodeArgs, "mychannel")
	fmt.Printf("INVOKE_CHAINCODE (from malware): %s", response.Message)

	return ctx.GetStub().PutState(id, malwareJSON)
}

// ReadMalware returns the malware entry stored in the world state with given id.
func (s *SmartContract) ReadMalware(ctx contractapi.TransactionContextInterface, id string) (*Malware, error) {
	malwareJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %v", err)
	}
	if malwareJSON == nil {
		return nil, fmt.Errorf("the malware %s does not exist", id)
	}

	var malware Malware
	err = json.Unmarshal(malwareJSON, &malware)
	if err != nil {
		return nil, err
	}

	return &malware, nil
}

// MalwareExists returns true when a malware entry with given ID exists in world state
func (s *SmartContract) MalwareExists(ctx contractapi.TransactionContextInterface, id string) (bool, error) {
	malwareJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return false, fmt.Errorf("failed to read from world state: %v", err)
	}

	return malwareJSON != nil, nil
}

// GetAllMalware returns all malware found in world state
func (s *SmartContract) GetAllMalware(ctx contractapi.TransactionContextInterface) ([]*Malware, error) {
	// range query with empty string for startKey and endKey does an
	// open-ended query of all malware in the chaincode namespace.
	resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	var malwares []*Malware
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return nil, err
		}

		var malware Malware
		err = json.Unmarshal(queryResponse.Value, &malware)
		if err != nil {
			return nil, err
		}
		malwares = append(malwares, &malware)
	}

	return malwares, nil
}
